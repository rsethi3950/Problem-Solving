# -*- coding: utf-8 -*-
"""ai_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LVfYHnS9_G1fjjaJ3ZU2w_3L_0byhjEU

##AI Assignment 2

#####RIYA               
#####101803256  
#####3CO12

###Q1.  8-puzzle problem
"""

# 8-puzzle problem
import math
start =[1,2,3,8,0,4,7,6,5]
goal =[2,8,1,0,4,3,7,6,5]
# cannot do this otherwise start will also change
# current = start
current = start[:]
path=[]

def Up():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx-3] = new[idx-3],  new[idx]
  return new

def right():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx+1] = new[idx+1],  new[idx]
  return new

def down():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx+3] = new[idx+3],  new[idx]
  return new

def left():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx-1] = new[idx-1],  new[idx]
  return new

def heruistic(node):
  misplaced=0
  dist=0
  for i in range(len(node)):
    if node[i]!=goal[i]:
      misplaced+=1
    # dist+= math.fabs(node.index(i)-goal.index(i))
  return (misplaced)

def enqueue(h,new):
  previous.append((hx,new))

def dequeue():
  path.append(current)
  curr = previous[0][1]
  previous.pop(0)
  return curr

h = heruistic(start)
previous =[(h,start)]
while(current!=goal and len(previous)!=0):

  if(current.index(0)-3>=0):
    n=Up()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if((current.index(0)+3)<=8):
    n=down()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if(current.index(0) not in (2,5,8)):
    n=right()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if(current.index(0) not in (0,3,6)):
    n=left()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)
      
  previous.sort(key= lambda x: x[0])
  current = dequeue()
if (current==goal):
  print('Done')
  path.append(current)
  print(path)
  print(len(path))
else:
  print('Not possible')

"""###Q2  water-jug problem"""

j1 = 4
j2 = 3
t = 2
visited= []
def jugSolver(water1, water2):
    cur = (water1,water2)
    if cur not in visited:
      visited.append(cur)

    if (water1 == t and water2 == 0) or (water1 == 0 and water2 == t):
        if water1==t:
        	return

        if water2 == t:
          water2=0
          water1=t
          print(water1,water2)
        return

    elif water2 == j2:
        jugSolver(water1, 0)

    elif water1 > 0:
      # transfer from j1 to j2
        if water1 <= j2-water2:
            jugSolver(0, water1+water2)
        elif water1 > j2-water2:
            jugSolver(water1-(j2-water2),water2+(j2-water2))

    else:
        jugSolver(j1, water2)

jugSolver(0,0)
print('Target achieved')
print(visited)

"""###Q3. Travelling Salesman Problem (TSP)"""

completed=dict()

lst =[[0,10,15,20],
      [10,0,35,25],
      [15,35,0,30],
      [20,25,30,0]]
def least(c):
  global cost
  nc=999
  kmin=999
  for i in range(0,4):
    if lst[c][i]!=0 and i not in completed.keys():
      if lst[c][i]<kmin:
        kmin=lst[c][i]
        nc=i
  if nc!=999:
    cost+=kmin
  return nc

def minCost(city):
  global cost
  completed[city]=1
  print(city+1,end=" ")
  ncity=least(city)
  if ncity==999:
    ncity=val
    print(start)
    cost+=lst[city][ncity]
    return;
  minCost(ncity)

cost=0
start= int(input())
val= start-1
minCost(val)
print('Minimum cost of visited is',end=" ")
print(cost)

import math
def bfs(j1,j2,t):
  q=[(0,0)]
  visited=[]
  solvable = False
  while len(q)!=0:
    cur = q[0]
    # print(cur)
    q.pop(0)
    if cur in visited:
      continue;
    if cur[0]<0 or cur[1]<0 or cur[0]>j1 or cur[1]>j2:
      continue;
    # if cur not in visited:
    visited.append(cur)
    if cur==(target,0):
      for amt in visited:
        solvable= True
        print(amt[0], amt[1])
      break;
    if cur[1]!=0:
      q.append((cur[0],0))
    if cur[0]!=0:
      q.append((0,cur[1]))

    # transfer from j2 to j1
    q.append((cur[0]+min(cur[1], (j1-cur[0])), cur[1]-min(cur[1],(j1-cur[0]))))

    # transfer from j1 to j2
    q.append((cur[0]-min(cur[0], (j2-cur[1])), cur[1]+min(cur[0],(j2-cur[1]))))
    if cur[0]!=j1:
      q.append((j1, cur[1]))
    if cur[1]!=j2:
      q.append((cur[0], j2))
    
  if not solvable:
    print('No solution')

j1=4
j2=3
target=2
bfs(j1, j2, target)