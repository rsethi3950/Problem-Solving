# -*- coding: utf-8 -*-
"""ai3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Kvc1ZEdR9oKctMknGpDsqjHxMRn8MWr8

####BEST FIRST SEARCH ALGORITHM
"""

# 8-puzzle problem
import math
start =[2,0,3,1,8,4,7,6,5]
goal =[1,2,3,8,0,4,7,6,5]
# cannot do this otherwise start will also change
# current = start
current = start[:]
path=[]

def Up():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx-3] = new[idx-3],  new[idx]
  return new

def right():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx+1] = new[idx+1],  new[idx]
  return new

def down():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx+3] = new[idx+3],  new[idx]
  return new

def left():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx-1] = new[idx-1],  new[idx]
  return new

def heruistic(node):
  misplaced=0
  dist=0
  for i in range(len(node)):
    if node[i]!=goal[i]:
      misplaced+=1
  return (misplaced)

def enqueue(h,new):
  previous.append((hx,new))

def dequeue():
  path.append(current)
  curr = previous[0][1]
  previous.pop(0)
  return curr

def pri(ele):
  if ele is None: return
  for i in range(9):
    print(ele[i],end=" ")
    if (i+1)%3 == 0:
      print('')
  print('')

h = heruistic(start)
previous =[(h,start)]
while(current!=goal and len(previous)!=0):

  if(current.index(0)-3>=0):
    n=Up()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if(current.index(0) not in (0,3,6)):
    n=left()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if((current.index(0)+3)<=8):
    n=down()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if(current.index(0) not in (2,5,8)):
    n=right()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)
    
  previous.sort(key= lambda x: x[0])
  current = dequeue()
if (current==goal):
  print('Done')
  path.append(current)
  # print(path)
  for j in range(len(path)):
    pri(path[j])
  print(len(path))
else:
  print('Not possible')

"""####HILL CLIMBING SEARCHING ALGORITHM"""

# 8-puzzle problem
import math
start =[2,0,3,1,8,4,7,6,5]
goal =[1,2,3,8,0,4,7,6,5]
# cannot do this otherwise start will also change
# current = start
current = start[:]
path=[]

def Up():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx-3] = new[idx-3],  new[idx]
  return new

def right():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx+1] = new[idx+1],  new[idx]
  return new

def down():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx+3] = new[idx+3],  new[idx]
  return new

def left():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx-1] = new[idx-1],  new[idx]
  return new

def heruistic(node):
  misplaced=0
  dist=0
  for i in range(len(node)):
    if node[i]!=goal[i]:
      misplaced+=1
  return (misplaced)

def enqueue(h,new):
  previous.append((hx,new))

def dequeue():
  path.append(current)
  if previous[0][0]<=heruistic(current):
    curr = previous[0][1]
    return curr
  return -1

def pri(ele):
  if ele is None: return
  for i in range(9):
    print(ele[i],end=" ")
    if (i+1)%3 == 0:
      print('')
  print('')

h = heruistic(start)
previous =[(h,start)]
while(current!=goal and len(previous)!=0):
  previous= []
  if(current.index(0)-3>=0):
    n=Up()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if(current.index(0) not in (0,3,6)):
    n=left()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if((current.index(0)+3)<=8):
    n=down()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if(current.index(0) not in (2,5,8)):
    n=right()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)
    
  previous.sort(key= lambda x: x[0])
  current = dequeue()
  if(current==goal):
     path.append(current) 
     break
  if current==-1 :
    break
if (current==goal):
  print('Done')
  # path.append(current)
  # print(path)
  
else:
  print('Not possible')
for j in range(len(path)):
  pri(path[j])
print(len(path))

"""####A* SEARCHING ALGORITHM"""

# 8-puzzle problem
import math
start =[2,0,3,1,8,4,7,6,5]
goal =[1,2,3,8,0,4,7,6,5]
# cannot do this otherwise start will also change
# current = start
current = start[:]
path=[]

def Up():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx-3] = new[idx-3],  new[idx]
  return new

def right():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx+1] = new[idx+1],  new[idx]
  return new

def down():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx+3] = new[idx+3],  new[idx]
  return new

def left():
  new = current[:]
  idx = new.index(0)
  new[idx], new[idx-1] = new[idx-1],  new[idx]
  return new

def heruistic(node):
  rightplaced=0
  dist=0
  for i in range(len(node)):
    if node[i]==goal[i]:
      rightplaced+=1
      # dist+= math.fabs(node.index(i)-goal.index(i))
  return (rightplaced)

def enqueue(h,new):
  previous.append((hx,new))

def dequeue():
  path.append(current)
  curr = previous[0][1]
  previous.pop(0)
  return curr

def pri(ele):
  if ele is None: return
  for i in range(9):
    print(ele[i],end=" ")
    if (i+1)%3 == 0:
      print('')
  print('')
  
h = heruistic(start)
previous =[(h,start)]
while(current!=goal and len(previous)!=0):

  if(current.index(0)-3>=0):
    n=Up()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if(current.index(0) not in (0,3,6)):
    n=left()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if((current.index(0)+3)<=8):
    n=down()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)

  if(current.index(0) not in (2,5,8)):
    n=right()
    hx=heruistic(n)
    if n not in path:
      enqueue(hx,n)
  
  previous.sort(key= lambda x: x[0],reverse=True)
  current = dequeue()
if (current==goal):
  print('Done')
  path.append(current)
  # print(path)
  for j in range(len(path)):
    pri(path[j])
  print(len(path))
else:
  print('Not possible')

"""####AO* SEARCHING ALGORITHM"""

global graph

def findindex(child):
    for i in range(len(graph)):
        if graph[i][0]==child:
            return i   
        
def calheu(root):
    curr_heu=graph[root][1]
    for children in graph[root][2]:
        new_heu=0
        for child in children:
            r=findindex(child)
            new_heu=new_heu+1+calheu(r)
        if new_heu<curr_heu:
            curr_heu=new_heu
    graph[root][1]=curr_heu        
    return curr_heu    
   
def printoptpath(root):
    print(graph[root][0],end='')
    if graph[root][2]!=[]:
        print('->',end='')
        q=[]
        for children in graph[root][2]:
                cost=-1
                for child in children:
                    r=findindex(child)
                    cost=cost+calheu(r)
                q=q+[[cost,children]]     
        q.sort()
        for i in q[0][1]:
            print('( ',end='')
            index=findindex(i)
            printoptpath(index)
            print(' )&',end='')
        print("\b ",end='',flush="False")    
            
    
graph=[['A',100000,[['B','C'],['D']]],
       ['B',6,[['G'],['H']]],
       ['C',12,[]],
       ['D',10,[['E','F']]],
       ['E',4,[]],
       ['F',4,[]],
       ['G',5,[]],
       ['H',7,[]]]
s=0
calheu(s)
print("Graph details are:")
for i in graph:
    print(i)
print("Optimal cost is: ",end=" ")
print(graph[s][1])
print("Optimal path is: ",end="")
printoptpath(s)